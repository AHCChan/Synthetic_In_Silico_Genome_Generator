HELP_DOC = """
FRAGMENT GENERATOR
(version 2.0)
by Angelo Chan

This is a program for generating DNA fragment sequences based on a template,
typically a genome.

In the context of a synthetic genome, this program will be used to generate
fragments from the genome, mimicking the DNA fragmentation process. Afterwards,
smaller sequences will be generated from the fragments, mimicking the NGS DNA
sequencing process.

The expected input is a folder containing one or more FASTA files. The fragments
will be output into a single FASTA file.



BACKGROUND INFO:

In whole genome next-gen sequencing protocols, the genome is fragmented into
smaller DNA fragments. However, with many sequencing technologies and protocols,
only the ends of the fragments are sequenced into reads.

Therefore, to achieve a desired level of coverage with a reads library, users
will typically need to generate a fragment library with a higher level of
coverage.

The formula is as follows:

    FRAG_COVERAGE = READ_COVERAGE * ( READ_SIZE / FRAG_SIZE)
        
        READ_SIZE is the size (bp) of the read(s) generated by the sequencer

        FRAG_SIZE is the size (bp) of the fragments generated here
        
        ( READ_SIZE / FRAG_SIZE ) calculates the average percentage of a
        fragment which will be sequenced.
        
        READ_COVERAGE is desired final average coverage level per nucleotide
        
        FRAG_COVERAGE is calculated from all of the above factors and is used to
        calculate the probability of a fragment being generated at each location



ABOUT COVERAGE DISTRIBUTION:

This verion of Generate_Fragments was intended to allow different parts of the
genome to be covered at different depths, while averaging out to be the depth of
coverage specified. However, rather than islands of the genome which are heavily
sequenced and deserts which are sparsely sequenced or ignored entirely, the
variation in depth of coverage occurs at an almost nucleotide level.

This is because the randomization process determines the distance between the
midpoints of fragments. Thus the distances between fragments will follow the
distribution specified. However, as long as the average distance is relatively
small compared to fragment sizes, the coverage at a nucleotide level will
generally amortize to around the average.

A proper implementation of the "islands and deserts" kind of distribution will
likely require, at the very least, a two-layered probability generation model.



USAGE:
    
    python27 Generate_Fragments.py <input_folder> [-o <output_filepath] [-d
            <depth_of_coverage>] [-c N|G|U <stdev>|<alpha_mod>|<max_dist>] [-r
            <read_length>] [-l <avg_frag_len>] [-f N|G|U
            <stdev>|<alpha_mod>|<max_dist>] [-m <method> [method_sup]...]



MANDATORY:
    
    input_folder
        
        The filepath of the input folder containing the FASTA file(s) from
        which the DNA fragments will be generated.

OPTIONAL:
    
    output_filepath
        
        (DEFAULT path generation available)
        
        The filepath of the output file where resultant FASTA file will be
        output into.
    
    depth_of_coverage
        
        (DEFAULT: 10)
        
        The average number of times a nucleotide will be "sequenced". If no
        read length is specified, or if a read length of -1 is specified, then
        it is assumed that each fragment is sequenced completely, without
        overlap.
        
        If a gamma distribution is used, the actual resulting depth of coverage
        will be lower than this.
    
    read_length
        
        (DEFAULT: -1)
        
        The number of nucleotides covered by each read or read-pair.
    
    avg_frag_len
        
        (DEFAULT: 500)
        
        The average length of the fragments to be produced.
    
    N|G|U
        
        (DEFAULT (-c): G)
        (DEFAULT (-f): N)
        
        The probability distribution used to generate fragments and determine
        fragment length.
            
            N   Normal variate distribution
            G   Gama variate distribution
            U   Uniform distribution
    
    stdev
        
        (Only applies if a Normal Variate distribution was specified)
        (DEFAULT: 50)
        
        The standard deviation of the normal distribution.
    
    alpha_mod
        
        (Only applies if a Gamma Variate distribution was specified)
        (DEFAULT: 1)
        
        The skewness factor of the Gamma distribution.
        
        The magnitude of @alpha_mod determines how unskewed the distribution is.
        As @alpha_mod approaches infinity, the resulting gamma distribution will
        begin to resemble a normal distribution. As @alpha approaches 0, the
        resulting gamma distribution will become increasingly skewed.
        
        It is known that, for a Gamma Distribution:
            
            Alpha * Beta ~= Desired_Average
        
        The Beta is automatically calculated such that:
            
            Alpha = Beta * Alpha_Mod
        
        A gamma variate distribution is right-tailed, with most values
        clustered to the left of the mean.
        
        A negative alpha may be specified to obtain a flipped and shifted
        gamma variate distribution, which will be left-tailed, with most values
        clusterd to the right of the mean. Please note that this is an
        unorthodox method. A better method should be implemented and used if
        users need a high fidelity left-tailed distribution.
        
    max_dist
        
        (Only applies if a Uniform distribution was specified)
        (DEFAULT: <depth_of_coverage>)
        
        The furthest away from the specified average which a randomly generated
        value can be. Cannot exceed the average. If @max_dist equals or exceeds
        the average, then the uniform distribution range will be from 0 to
        double whatever the average is.
        
        Ex. If it is specified that the average fragment length is 500 and that
        the fragments are to follow a uniform distribution with a @max_dist of
        50, then all fragment lengths will be between 450 and 550 in length.
    
    (-c)
        
        Used to signify that the following parameters pertain to the probability
        distribution of read/fragment coverage.
        Ex. "-c G 1.0" signifies that the coverage of nucleotides follows a
        gamma variate distribution with an Alpha of 1.0. (The average coverage
        is specified using the "-d" flag.)
    
    (-f)
        
        Used to signify that the following parameters pertain to the probability
        distribution of fragment sizes.
        Ex. "-c N 50" signifies that the fragment sizes follow a normal
        distribution, with a standard deviation of 50. (The average read length
        is specified using the "-r" flag.)
    
    method
        
        (DEFAULT: ALL)
        Method of deciding where fragments can be generated. Fragments generated
        using restriction enzymes will only occur at certain locations, while
        fragments generated using sonication can start or begin at any
        nucleotide.
    
    method_sup
        
        Supplementary inputs, as required, for deciding where fragments can be
        generated. Currently not reelvant because the only method implemented
        does not require any additional inputs.



EXAMPLES SCENARIO EXPLANATION:
    
    1:
    An almost bare minimum use case. (Specifying the output path is not
    mandatory, but it is good practice to do so.)
    
    2:
    The "fragments" will be pair-end sequenced with 2x75 reads, hence "-r 150".
    Since only 150 of the 500 bp will be sequenced, more fragments will be
    generated to ensure that the final coverage levels will be the 10. (Default
    depth of coverage)
    
    3:
    The "fragments" were generated by hydrolysis with an average length of 300,
    and a modestly left skew. (Gamma variate distribution with an Alpha of 1)
    
    4:
    Some parts of the genome were less accessible during the fragmentation and
    amplification procedure, so coverage is heavily skewed. Some parts of the
    genome have very deep coverage, while other parts have very little. Note
    that this probability distribution has been done on a base-pair level rather
    than a loci level, and is thus, not a good imitation of the biological
    phenomenon described.
    
    5:
    The sonication and subsequent size selection steps were carried out poorly,
    resulting in a normally distributed, but broadly distributed range of
    fragment sizes. (Standard deviation of 200)
    
    6:
    The "fragments" are uniformly distributed in size, between 500bp and 600bp.
    The average is specified as 550, while the maximum distance is specified as
    50 to achieve this outcome.
    
    7:
    The "fragments" are all exactly 800bp in size. To achieve this, the average
    is specified as 800, and the distribution of fragment sizes is specified as
    a normal distribution with a standard deviation of 0. The depth of coverage
    was also increased.

EXAMPLES:
    
    python27 Generate_Fragments.py Path/GenomeFolder -o Output.fa
    
    python27 Generate_Fragments.py Path/GenomeFolder -r 150
    
    python27 Generate_Fragments.py Path/GenomeFolder -l 300 -f G 1
    
    python27 Generate_Fragments.py Path/GenomeFolder -c G 0.1
    
    python27 Generate_Fragments.py Path/GenomeFolder -f N 200
    
    ----------------------------------------------------------------------------
    
    python27 Generate_Fragments.py Path/GenomeFolder -l 550 -f U 50
    
    python27 Generate_Fragments.py Path/GenomeFolder -l 800 -f N 0 -d 20

USAGE:
    
    python27 Generate_Fragments.py <input_folder> [-o <output_filepath] [-d
            <depth_of_coverage>] [-c N|G|U <stdev>|<alpha_mod>|<max_dist>] [-r
            <read_length>] [-l <avg_frag_len>] [-f N|G|U
            <stdev>|<alpha_mod>|<max_dist>] [-m <method> [method_sup]...]
"""

NAME = "Generate_Fragments.py"



# Configurations ###############################################################

AUTORUN = True

WRITE_PREVENT = False # Completely prevent overwritting existing files
WRITE_CONFIRM = True # Check to confirm overwritting existing files

PRINT_ERRORS = True
PRINT_PROGRESS = True
PRINT_METRICS = True



# Minor Configurations #########################################################

FILEMOD__FASTA = "__FRAGMENTS.fa"

# For name string
ID_SIZE = 15
STR__forward = "F"
STR__reverse = "R"




# Defaults #####################################################################
"NOTE: altering these will not alter the values displayed in the HELP DOC"
    
DEFAULT__depth = 10
DEFAULT__read_len = -1
DEFAULT__frag_len = 500
DEFAULT__cov_dist = 2 # DIST.GAMMA = 2. Alter this if the DIST enum is altered
DEFAULT__cov_num = 1
DEFAULT__frag_dist = 1 # DIST.NORMAL = 1. Alter this if the DIST enum is altered
DEFAULT__frag_num = 50
DEFAULT__method = 1



# Imported Modules #############################################################

import sys
import os

import random as Random



import _Controlled_Print as PRINT
from NSeq_Match import *
from _Command_Line_Parser import *
from Deque import *

from Chr_FASTA_File_Reader import *



# Enums ########################################################################

class DIST: # For Distribution
    NORMAL=1 # If this is changed, sync relevant defaults
    GAMMA=2
    UNIFORM=3

class METHOD:
    ALL=1



# Strings ######################################################################

STR__use_help = "\nUse the -h option for help:\n\t python "\
"Generate_Fragments.py -h"

STR__error_no_FASTA = """
ERROR: No FASTA files detected in:
    {f}"""

STR__invalid_dist = """
ERROR: Invalid statistical distribution: {s}
Please specify one of:
    NORMAL
    GAMMA
    UNIFORM"""

STR__invalid_depth = """
ERROR: Invalid depth of coverage: {s}
Please specify a positive number."""

STR__invalid_cov_param = """
ERROR: Invalid nucleotide coverage parameters:
    (Distribution): {d}
    (Parameter):    {p}

For the distribution model, please specify one of:
    NORMAL
    GAMMA
    UNIFORM

For the parameter, depending on the distribution model chosen, please specify:
    NORMAL - A non-negative number.
    GAMMA - A non-zero number.
    UNIFORM - (Unnecessary)"""

STR__invalid_frag_param = """
ERROR: Invalid fragment length parameters:
    (Distribution): {d}
    (Parameter):    {p}

For the distribution model, please specify one of:
    NORMAL
    GAMMA
    UNIFORM

For the parameter, depending on the distribution model chosen, please specify:
    NORMAL - A non-negative number.
    GAMMA - A non-zero number.
    UNIFORM - A non-negative integer."""

STR__invalid_read_len = """
ERROR: Invalid read length: {s}
Please specify a positive integer."""

STR__invalid_frag_len = """
ERROR: Invalid fragment length: {s}
Please specify a positive integer."""

STR__invalid_method = """
ERROR: Invalid fragmentation method: {s}
Please specify one of:
    ALL
    (other options currently not implemented)"""



STR__input_invalid = "\nERROR: An unexpected error occured when reading from "\
        "the input file(s)."
STR__output_invalid = "\nERROR: An unexpected error occured when writing to "\
        "the output file."
STR__generation_invalid = "\nERROR: An unexpected error occured during the "\
        "fragment generation process."



STR__metrics = """
    Total fragments generated: {C}
        Average fragment size: {A}"""

STR__GenFrags_begin = "\nRunning Generate_Fragments..."

STR__GenFrags_complete = "\nGenerate_Fragments successfully finished."



# String Lists #################################################################

STR_LIST__specify_dist_param = [ # Indexes are based on the DIST enum
"""
ERROR: Please specify the standard deviation you want your normal distribution
to have. The standard deviations must be a positive number.""","""
ERROR: Please specify the alpha you want your gamma distribution to have. If the
alpha ius negative, a flipped and shifted gamma distribution will be applied
instead of a normal gamma distribution.""","""
ERROR: Please specify the maximum distance from the average you want your
uniformly distributed values to have. The maximum distance must be a
non-negative number."""]



# Lists ########################################################################

LIST__normal = ["N", "n", "NORMAL", "Normal", "normal", "NORM", "Norm", "norm"]
LIST__gamma = ["G", "g", "GAMMA", "Gamma", "gamma"]
LIST__uniform = ["U", "u", "UNIFORM", "Uniform", "uniform", "UNI", "Uni", "uni"]



# Dictionaries #################################################################

DICT__dists = {}
for i in LIST__normal: DICT__dists[i] = DIST.NORMAL
for i in LIST__gamma: DICT__dists[i] = DIST.GAMMA
for i in LIST__uniform: DICT__dists[i] = DIST.UNIFORM

DICT__methods = {}
for i in LIST__all: DICT__methods[i] = METHOD.ALL



# Apply Globals ################################################################

PRINT.PRINT_ERRORS = PRINT_ERRORS
PRINT.PRINT_PROGRESS = PRINT_PROGRESS
PRINT.PRINT_METRICS = PRINT_METRICS



# Functions ####################################################################

def Generate_Fragments(path_in, path_out, depth_settings, read_len,
            frag_settings, method_settings):
    """
    Generate a series of DNA fragments from the DNA templates in a folder of
    FASTA files.
    
    @path_in
            (str - dirpath)
            The filepath of the folder containing the FASTA file(s) containing
            the original DNA templates which the fragments are based on.
    @path_out
            (str - filepath)
            The file to which the output is written.
    @depth_settings
            ([int, int, float])
            The "depth of coverage" settings.
            A list containing the following three variables:
                1)  (int)
                    The average depth of coverage for the DNA templates by the
                    reads which will be generated using the fragments.
                2)  (int) - Pseudo ENUM
                    An int which signifies which statistical distribution to
                    use when determining the likelihood of a fragment (and thus
                    coverage) being generated at any particular location:
                        0: Normal distribution
                        1: Gamma distribution
                        2: Uniform distribution
                3)  (float)
                    The paramter variable to use for the statistical
                    distribution specified by the second variable in this list.
                    Its meaning will vary depending on the distribution:
                        NORMAL DISTRIBUTION:
                            This variable is the standard deviation.
                        GAMMA DISTRIBUTION:
                            This variable is the alpha modifier of the
                            distribution. The beta value is automatically
                            calculated such at A*B=Average_Depth. If a negative
                            value is provided, the distribution used will change
                            to a flip-shifted gamma distribution.
                        UNIFORM DISTRIBUTION:
                            (Only relevant for fragment lenth settings)
                            This variable is the difference between the mean of
                            the distribution, and either the upper or lower
                            limits of the distribution range.
    @read_len
            (int)
            The intended total length of the reads which will be generated by
            the fragments. If 0 or -1, this will indicate that the fragments
            will be sequenced in their entirety without overlapping reads.
    @frag_settings
            ([int, int, float])
            The "fragment length" settings.
            A list containing the following three variables:
                1)  (int)
                    The average length of the fragments to be generated.
                2)  (int) - Pseudo ENUM
                    An int which signifies which statistical distribution to
                    use when determining the length of a fragment when one is
                    generated:
                        0: Normal distribution
                        1: Gamma distribution
                        2: Uniform distribution
                3)  (float)
                    The paramter variable to use for the statistical
                    distribution specified by the second variable in this list.
                    Its meaning will vary depending on the distribution:
                        NORMAL DISTRIBUTION:
                            This variable is the standard deviation.
                        GAMMA DISTRIBUTION:
                            This variable is the alpha value of the
                            distribution. The beta value is automatically
                            calculated such at A*B=1. If a negative value is
                            provided, the distribution used will change to a
                            flip-shifted gamma distribution.
                        UNIFORM DISTRIBUTION:
                            This variable is the difference between the mean of
                            the distribution, and either the upper or lower
                            limits of the distribution range.
    @method_settings
            ([int, *...])
            The "method for determining fragment starts and ends" settings.
            A list of variables containing all settings relevant to determining
            where fragments can start and end. The first variable is as follows:
                (int) - Pseudo ENUM
                An int which signifies where fragments can start and end. 
                    0: All
            What other variables are required depend on the first integer:
                ALL:
                    No other variables are necessary.
    
    Return a value of 0 if the function runs successfully.
    Return a value of 1 if there is a problem accessing the data or if there are
            no valid FASTA files in the input folder.
    Return a value of 2 if there is a problem with the output file.
    Return a value of 3 if there is a problem during the fragment generation
            process.
    
    Generate_Fragments(str, str, [int, int, float], int, [int, int, float],
            [int, *...]) -> int
    """
    # Setup reporting
    outcomes = [] # Outcomes are added after each input file is processed
    # Setup the I/O
    paths_in = Get_Files_W_Extensions(path_in, LIST__FASTA)
    if not paths_in: return 1
    try:
        o = open(path_out, "w")
    except:
        return 2
    # Main loop
    PRINT.printP(STR__GenFrags_begin)
    for path in paths_in:
        outcome = Generate_Fragments__FILE(path, o, depth_settings,
                read_len, frag_settings, method_settings)
        if outcome: outcomes.append(outcome)
        else:
            o.close()
            return 3
    # Finish up
    o.close()
    PRINT.printP(STR__GenFrags_complete)
    # Reporting
    Report_Metrics(outcomes)
    # Wrap up
    return 0

def Generate_Fragments__FILE(path_in, output, depth_settings, read_len,
            frag_settings, method_settings):
    """
    Generate a series of DNA fragments from the DNA template in the input file
    specified by [path_in].
    
    The per-input-file version of the Generate_Fragments() function.
    
    @path_in
            (str - dirpath)
            The filepath of the input file.
    @path_out
            (str - dirpath) OR
            (file)
            The filepath of the file to which the output is written, OR the file
            itself as a file object.
    @depth_settings
            ([int, int, float])
            The "depth of coverage" settings.
            See Generate_Fragments() documentation for details.
    @read_len
            (int)
            The intended total length of the reads which will be generated by
            the fragments. If 0 or -1, this will indicate that the fragments
            will be sequenced in their entirety without overlapping reads.
    @frag_settings
            ([int, int, float])
            The "fragment length" settings.
            See Generate_Fragments() documentation for details.
    @method_settings
            ([int, *...])
            The "method for determining fragment starts and ends" settings.
            See Generate_Fragments() documentation for details.
    
    Return a list containing the number of number of fragments generated and
    their total length.
    Return an empty list if an error occured.
    
    Generate_Fragments(str, str/file, [int, int, float], int, [int, int, float],
            [int, *...]) -> [int, int]
    """
    print depth_settings, frag_settings
    # Metrics setup
    count = 0
    total = 0
    
    # Unpack
    depth, depth_method, depth_param = depth_settings
    frag_len, frag_len_method, frag_len_param = frag_settings
    method = method_settings[0]
    
    # Calculations
    average_dist = float(read_len)/depth
    
    # Calculations (maximum length)
    if frag_len_method == DIST.NORMAL: max_len = 5 * frag_len
    if frag_len_method == DIST.GAMMA: max_len = 5 * frag_len
    if frag_len_method == DIST.UNIFORM: max_len = 5 * frag_len + frag_len_param
    
    # Calculate (distribution parameters)
    if depth_method == DIST.GAMMA:
        if depth_param < 0:
            flag = True
            depth_param = -depth_param
        else: flag = False
        beta = (average_dist / depth_param) ** 0.5
        alpha = average_dist / beta
        depth_param = [alpha, beta, flag]
    elif depth_method == DIST.UNIFORM:
        lower = int(average_dist) - frag_len_param
        upper = int(average_dist + 0.5) + frag_len_param
        depth_param = range(lower, upper+1)
        average_dist = 0
    
    if frag_len_method == DIST.GAMMA:
        if frag_len_param < 0:
            flag = True
            frag_len_param = -frag_len_param
        else: flag = False
        beta = (frag_len / frag_len_param) ** 0.5
        alpha = frag_len / beta
        frag_len_param = [alpha, beta, flag]
    elif frag_len_method == DIST.UNIFORM:
        lower = frag_len - frag_len_param
        upper = frag_len + frag_len_param
        frag_len_param = range(lower, upper+1)
        frag_len = 0
    
    # I/O setup
    f = Chr_FASTA_Reader(path_in, True)
    if type(output) == str: o = open(output, "w")
    else: o = output
    
    # Setup
    until_next = 1
    new_frags = 0
    
    current_index = 0
    counter = 0
    frags = [] # Unfinished frags [start, end, direction, seq]
    
    previous = Deque(max_len, "N")
    
    # Main Loop
    while not f.End():
        f.Read()
        current_index += 1
        n = f.Get_Current()
        
        previous.Add(n)
        
        # Calculate next frag, also number of frags at current position
        until_next -= 1
        if until_next == 0:
            # Random until next
            until_next = Custom_Random_Distribution(average_dist, depth_method,
                    depth_param)
            until_next = int(until_next + 0.5)
            # Number of new frags, adjust until_next
            new_frags = 1
            if until_next < 1:
                new_frags = 2 - until_next
                until_next = 1
            
        # For all frags
        temp = []
        for frag in frags: # [start, end, direction, seq]
            frag[3].append(n)
            if current_index == frag[1]: # End of frag reached
                counter += 1
                seq = "".join(frag[3])
                if frag[2]:
                    direction = STR__forward
                else:
                    direction = STR__reverse
                    seq = Get_Complement(seq, True)
                name = Generate_Frag_Name(counter, frag[0], direction, frag[1])
                # Write
                s = ">" + name + "\n" + seq + "\n"
                o.write(s)
                # Metrics
                size = end - start + 1
                count += 1
                total += size
            else: # Frag still going
                temp.append(frag)
        frags = temp
        
        # New frags
        while new_frags > 0:
            new_frags -= 1
            # Length
            length = Custom_Random_Distribution(frag_len, frag_len_method,
                    frag_len_param)
            if length < 3: length = 3
            if length > max_len: length = max_len
            # Coin Flip
            coin_flip = Random.random()
            if coin_flip < 0.5: sense = True
            else: sense = False
            # Coordinates
            half = length/2
            if length % 2 == 1: # Odd length
                backtrack = half + 1
                start = current_index - half
                end = current_index + half
            else: # Even length
                if sense:
                    backtrack = half
                    start = current_index - half
                    end = current_index + half
                else:
                    backtrack = half + 1
                    start = current_index - half - 1
                    end = current_index + half - 1
            # Out Of Bounds
            if current_index - backtrack < 0:
                # Out of bounds
                pass
            else:
                # Not out of bounds
                seq = previous.Poll(backtrack)
                frags.append([start, end, sense, seq])
    
    # Close file
    if type(output) == str: o.close()
    
    # Return
    return [count, total]

def Report_Metrics(outcomes):
    """
    Print a report into the command line interface of the total number of
    fragments generated, and the average length.
    
    @outcomes
            (list<[int,int]>)
            A list of sublists, each containing two integers, a fragment count,
            and the total number of basepairs in the fragments.
    
    Report_Metrics(list<[int,int]>) -> None
    """
    # Can potentially be expanded to include more metrics in the future
    # Get results
    count = 0
    total = 0
    for outcome in outcomes:
        count += outcome[0]
        total += outcome[1]
    if count: average = int((float(total)/count) + 0.5)
    else: average = 0
    # Strings
    str_count = str(count)
    str_average = str(average)
    # Padding and formatting
    max_size = max([len(str_count), len(str_average)])
    str_count = Pad_Str(str_count, max_size, " ", 0)
    str_average = Pad_Str(str_average, max_size, " ", 0)
    # Print
    PRINT.printM(STR__metrics.format(C = str_count, A = str_average))

def Custom_Random_Distribution(mean, method, param, must_positive=False):
    """
    MAY BE DIFFERENT FROM OTHER Custom_Random_Distribution FUNCTIONS IN OTHER
    PROGRAMS.
    
    Generate a random integer.
    
    The distribution of the amortized results of this function being run,
    multiple times, with the same parameters, will be equal to [mean], or
    [mean]+[param] in the case of certain uniform distributions.

    MAJORLY DIFFERING SPECIAL BEHAVIOUR:
    If [mean] is 0 and the normal distribution method is chosen, one of the
    values in [param] will be chosen at random
    
    @mean
            (int/float)
            The desired average outcome.
            In the case where a Uniform distribution is chosen and @mean is not
            0, then the average outcome of this function with the same
            parameters will be @mean+@param.
    @method
            (int) - Pseudo ENUM
            An integer signifying which probability distribution to use:
                0: Normal distribution
                1: Gamma distribution
                2: Uniform distribution
    @param
            (*)
            Varies depending on the distribution method chosen:
                NORMAL DISTIRBUTION:
                    (float)
                    The standard deviation of the normal distribution.
                GAMMA DISTRIBUTION:
                    ([float, float, bool])
                    A list containing the Alpha and Beta to be used for the
                    Gamma distribution, and a flag indicating whether to
                    flip-shift the result or not.
                UNIFORM:
                    If @mean is 0, then @param is a list of values, one of which
                    will be chosen at random with equal probability.
                    If @mean is not zero, then @param is the number to add,
                    essentially resulting in a series of numbers which are
                    either FLOOR(@mean) or CEILING(@mean), the average of which
                    is @mean.
    @must_positive
            (bool)
            Whether or not to forcibly make the result positive if it is
            negative.
    
    Custom_Random_Distribution(int/float, int, *, bool) -> int/float
    """
    if method == DIST.UNIFORM:
        if mean:
            r = Random.random()
            if r > mean: return param+1
            else: return param
        else:
            r = Random.choice(param)
    else:
        if method == DIST.NORMAL:
            r = Random.normalvariate(mean, param)
        elif method == DIST.GAMMA:
            r = Random.gammavariate(param[0], param[1])
            if param[2]: r = -r + 2
        r = int(r+0.5)
    if must_positive:
        if r < 0: r = -r
    return r
    
def Generate_Frag_Name(counter, start, direction, end):
    """
    Generate a name for a DNA fragment based on how many fragments have already
    been generated, and the coordinates and directionality of the fragment.
    """
    sb = Pad_Str(str(counter), ID_SIZE, "0", 0)
    sb = sb + "__" + str(start) + "_" + direction + "_" + str(end)
    return sb



# Command Line Parsing #########################################################

def Parse_Command_Line_Input__Generate_Fragments(raw_command_line_input):
    """
    Parse the command line input and call the Generate_Fragments function
    with appropriate arguments if the command line input is valid.
    """
    PRINT.printP(STR__parsing_args)
    # Remove the runtime environment variable and program name from the inputs
    inputs = Strip_Non_Inputs(raw_command_line_input, NAME)
    
    # No inputs
    if not inputs:
        PRINT.printE(STR__no_inputs)
        PRINT.printE(STR__use_help)
        return 1
    
    # Help option
    if inputs[0] in LIST__help:
        print(HELP_DOC)
        return 0
    
    # Initial validation (Redundant in current version)
    if len(inputs) < 1:
        PRINT.printE(STR__insufficient_inputs)
        PRINT.printE(STR__use_help)
        return 1
    
    # Validate mandatory inputs
    path_in = inputs.pop(0)
    valid = Validate_FASTA_Folder(path_in)
    if valid == 1:
        PRINT.printE(STR__IO_error_read_folder)
        PRINT.printE(STR__use_help)
        return 1
    elif valid == 2:
        PRINT.printE(STR__error_no_FASTA.format(f = path_in))
        PRINT.printE(STR__use_help)
        return 1
    
    # Set up rest of the parsing
    path_out = Generate_Default_Output_File_Path_From_Folder(path_in,
            FILEMOD__FASTA)
    read_len = DEFAULT__read_len
    depth = DEFAULT__depth
    cov_dist = DEFAULT__cov_dist
    cov_num = DEFAULT__cov_num
    frag_len = DEFAULT__frag_len
    frag_dist = DEFAULT__frag_dist
    frag_num = DEFAULT__frag_num
    method = DEFAULT__method
    
    # Validate optional inputs (except output path)
    while inputs:
        arg = inputs.pop(0)
        try: # Second argument
            arg2 = inputs.pop(0)
        except:
            PRINT.printE(STR__insufficient_inputs)
            PRINT.printE(STR__use_help)
            return 1
        if arg == "-o": # Output files
            path_out = arg2
        elif arg == "-d": # Depth of coverage
            depth = arg2
            depth = Validate_Float_Positive(arg2)
            if depth == 0:
                PRINT.printE(STR__invalid_depth.format(s = arg2))
                return 1
        elif arg == "-c": # Coverage parameters
            try: # Third argument
                arg3 = inputs.pop(0)
            except:
                PRINT.printE(STR__insufficient_inputs)
                PRINT.printE(STR__use_help)
                return 1
            cov_params = Validate_Dist_Params(arg2, arg3)
            if not cov_params:
                PRINT.printE(STR__invalid_cov_param.format(d = arg2, p = arg3))
                return 1
            cov_dist, cov_num = cov_params
        elif arg == "-r": # Read length
            if read_len == "-1": read_len = -1
            else:
                read_len = Validate_Int_Positive(arg2)
                if read_len == -1:
                    PRINT.printE(STR__invalid_read_len.format(s = arg2))
                    return 1
        elif arg == "-l": # Fragment length
            frag_len = Validate_Int_Positive(arg2)
            if frag_len == -1:
                PRINT.printE(STR__invalid_frag_len.format(s = arg2))
                return 1
        elif arg == "-f": # Fragment parameters
            try: # Third argument
                arg3 = inputs.pop(0)
            except:
                PRINT.printE(STR__insufficient_inputs)
                PRINT.printE(STR__use_help)
                return 1
            frag_params = Validate_Dist_Params(arg2, arg3)
            if not frag_params:
                PRINT.printE(STR__invalid_frag_param.format(d = arg2, p = arg3))
                return 1
            frag_dist, frag_num = frag_params
        elif arg == "-m": # Method
            method = DICT__methods.get(arg2, None)
            if not method:
                PRINT.printE(STR__invalid_method.format(s = arg))
                return 1
        else: # Invalid
            arg = Strip_X(arg)
            PRINT.printE(STR__invalid_argument.format(s = arg))
            PRINT.printE(STR__use_help)
            return 1
    
    # Processing
    if read_len == -1: read_len = frag_len
    
    # Validate output path
    valid_out = Validate_Write_Path(path_out)
    if valid_out == 2: return 0
    if valid_out == 3:
        PRINT.printE(STR__IO_error_write_forbid)
        return 1
    if valid_out == 4:
        PRINT.printE(STR__IO_error_write_unable)
        return 1
    
    # Run program
    exit_state = Generate_Fragments(path_in, path_out, [depth, cov_dist,
            cov_num], read_len, [frag_len, frag_dist, frag_num], [method])
    
    # Exit
    if exit_state == 0: return 0
    else:
        if exit_state == 1: PRINT.printE(STR__input_invalid)
        if exit_state == 2: PRINT.printE(STR__output_invalid)
        if exit_state == 3: PRINT.printE(STR__generation_invalid)
        PRINT.printE(STR__use_help)
        return 1

def Validate_Dist_Params(method, param):
    """
    Validates the statistical distribution parameters; [method] needs to be text
    indicating a valid distribution, and [param] needs to specify valid
    parameters for said distribution, and will depend on [method].
    
    Return a list containing a pseudo-enum int and a second variable if the
    parameters are valid.
    Return an empty list if the parameters are invalid.
    
    Valid values for [method] include "Normal", "Gamma", and "Uniform", and all
    capitalization variants of these strings.
    
    Regarding param:
        
        For a normal distribtions, [param] is the standard deviation, a
        non-negative number.
        
        For a gamma distribution, [param] is the ratio between alpha and beta.
        The greater it's value, the greater the ratio between the alpha and beta
        values, and the more skwewed the data becomes. For negative [param]
        values, the distribution is flip-shifted.
        
        For a uniform distribution, [param] is how far away from the average the
        distribution range goes.
    
    Validate_Dist_Params(str, str) -> list<*>
    """
    dist = DICT__dists.get(method, 0)
    if dist == 1: # Normal
        param = Validate_Float_NonNeg(param)
        if param == -1: return []
    elif dist == 2: # Gamma
        param = Validate_Float_NonZero(param)
        if param == -1: return []
    elif dist == 3: # Uniform
        param = Validate_Int_NonNeg(param)
        if param == -1: return []
    else:
        return []
    return [dist, param]

def Validate_Write_Path(filepath):
    """
    Validates the filepath of the output file.
    Return 0 if the filepath is writtable.
    Return 1 if the user decides to overwrite an existing file.
    Return 2 if the user declines to overwrite an existing file.
    Return 3 if the file exists and the program is set to forbid overwriting.
    Return 4 if the program is unable to write to the filepath specified.
    
    Validate_Write_Path(str) -> int
    """
    try:
        f = open(filepath, "U")
        f.close()
    except: # File does not exist. 
        try:
            f = open(filepath, "w")
            f.close()
            return 0 # File does not exist and it is possible to write
        except:
            return 4 # File does not exist but it is not possible to write
    # File exists
    if WRITE_PREVENT: return 3
    if WRITE_CONFIRM:
        confirm = raw_input(STR__overwrite_confirm.format(f = filepath))
        if confirm not in LIST__yes: return 2
    # User is not prevented from overwritting and may have chosen to overwrite
    try:
        f = open(filepath, "w")
        f.close()
        if WRITE_CONFIRM: return 1 # User has chosen to overwrite existing file
        return 0 # Overwriting existing file is possible
    except:
        return 4 # Unable to write to specified filepath
    
    

def Validate_FASTA_Folder(dirpath):
    """
    Validates the dirpath of the input file as containing FASTA files.
    Return 0 if the dirpath is valid and contains at least 1 FASTA file.
    Return 1 if the dirpath is valid but contains no FASTA files.
    Return 2 if the dirpath is invalid.
    
    Validate_Read_Path(str) -> int
    """
    try:
        os.listdir(dirpath)
        files = Get_Files_W_Extensions(dirpath, LIST__FASTA)
        if len(files) > 0: return 0
        return 1
    except:
        return 2



# Main Loop ####################################################################

if AUTORUN and (__name__ == "__main__"):
    exit_code = Parse_Command_Line_Input__Generate_Fragments(sys.argv)


